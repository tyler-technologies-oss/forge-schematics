import { Tree } from '@angular-devkit/schematics';
import { SchematicTestRunner } from '@angular-devkit/schematics/testing';
import * as path from 'path';
import { IOptions } from './options.interface';

const collectionPath = path.join(__dirname, '../collection.json');

function defaultOptions(): IOptions {
  return {
    manifest: 'src/custom-elements/test-manifest.json',
    importPath: '@tylertech/forge',
    exclude: '',
    outDir: '',
    outDirExcludePrefix: '',
    modulePrefix: '',
    useDefineFunction: false
  };
}

describe('custom-elements', () => {
  it('should generate a component and module for each element in a folder matching the tag name', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', defaultOptions(), Tree.empty())
      .toPromise();

    expect(tree.files).toEqual([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts',
      '/forge-expansion-panel/expansion-panel.component.ts',
      '/forge-expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should overwrite a module in the target directory if it includes the standard comment indicating it was generated', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const oldGeneratedFileContent = `// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.\nold content`
    const startingTree = Tree.empty();
    startingTree.create('forge-accordion/accordion.module.ts', oldGeneratedFileContent);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', defaultOptions(), startingTree)
      .toPromise();

    expect(tree.files).toEqual(jasmine.arrayContaining([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts'
    ]));
    expect(tree.get('forge-accordion/accordion.module.ts')?.content.toString()).not.toEqual(oldGeneratedFileContent);
  });

  it('should generating the module file ending in -proxy if one already exists in the target directory', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const startingTree = Tree.empty();
    const nonGeneratedContent = 'test';
    startingTree.create('forge-accordion/accordion.module.ts', nonGeneratedContent);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', defaultOptions(), startingTree)
      .toPromise();

    expect(tree.files).toEqual(jasmine.arrayContaining([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts',
      '/forge-accordion/accordion-proxy.module.ts'
    ]));
    expect(tree.get('forge-accordion/accordion.module.ts')?.content.toString()).toEqual(nonGeneratedContent);
    expect(tree.get('forge-accordion/accordion-proxy.module.ts')?.content.toString()).toContain('export class AccordionProxyModule');
  });

  it('should generate the folders in the outDir if specified', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', {
        ...defaultOptions(),
        outDir: 'test'
      }, Tree.empty())
      .toPromise();

    expect(tree.files).toEqual([
      '/test/forge-accordion/accordion.component.ts',
      '/test/forge-accordion/accordion.module.ts',
      '/test/forge-expansion-panel/expansion-panel.component.ts',
      '/test/forge-expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should omit the forge prefix from the folder if outDirExcludePrefix is specified', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', {
        ...defaultOptions(),
        outDirExcludePrefix: 'forge-',
      }, Tree.empty())
      .toPromise();

    expect(tree.files).toEqual([
      '/accordion/accordion.component.ts',
      '/accordion/accordion.module.ts',
      '/expansion-panel/expansion-panel.component.ts',
      '/expansion-panel/expansion-panel.module.ts',
    ]);
  });

  it('should generate exclude a component by tag name', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', {
        ...defaultOptions(),
        exclude: 'forge-accordion, forge-expansion-panel'
      }, Tree.empty())
      .toPromise();

    expect(tree.files).toEqual([]);
  });

  it('should use the built-in customElements.define function if useDefineFunction is false', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', {
        ...defaultOptions(),
        useDefineFunction: false
      }, Tree.empty())
      .toPromise();

    const componentFile = tree.readContent(tree.files[0]);
    const moduleFile = tree.readContent(tree.files[1]);
    expect(componentFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
    expect(componentFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
    expect(moduleFile).toContain(`import { AccordionComponent as AccordionComponentCustomElement } from '@tylertech/forge';`);
    expect(moduleFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
    expect(moduleFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
  });

  it('should use the library define function if useDefineFunction is true', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', {
        ...defaultOptions(),
        useDefineFunction: true
      }, Tree.empty())
      .toPromise();

    const componentFile = tree.readContent(tree.files[0]);
    const moduleFile = tree.readContent(tree.files[1]);
    expect(componentFile).toContain(`, defineAccordionComponent } from '@tylertech/forge';`);
    expect(componentFile).toContain(`defineAccordionComponent()`);
    expect(moduleFile).toContain(`import { defineAccordionComponent } from '@tylertech/forge';`);
    expect(moduleFile).toContain(`defineAccordionComponent()`);
  });

  it('should accept a config file rather than individual arguments', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', { config: 'src/custom-elements/test-config.json' }, Tree.empty())
      .toPromise();

    expect(tree.files).toEqual([
      '/test/accordion/accordion.component.ts',
      '/test/accordion/accordion.module.ts',
      '/test/expansion-panel/expansion-panel.component.ts',
      '/test/expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should accept a map of dependencies and generate imports/exports in the module', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematicAsync<IOptions>('custom-elements', { config: 'src/custom-elements/test-config.json' }, Tree.empty())
      .toPromise();

    const accordionModuleFile = tree.readContent(tree.files[1]);
    expect(accordionModuleFile).toContain(`import { ForgeExpansionPanelModule } from '../expansion-panel/expansion-panel.module';`);
    expect(accordionModuleFile).toContain(`imports: [CommonModule, ForgeExpansionPanelModule]`);
    expect(accordionModuleFile).toContain(`exports: [AccordionComponent, ForgeExpansionPanelModule]`);
  });

});