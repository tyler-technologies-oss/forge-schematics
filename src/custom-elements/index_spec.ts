import { Tree } from '@angular-devkit/schematics';
import { SchematicTestRunner } from '@angular-devkit/schematics/testing';
import * as path from 'path';
import { IOptions } from './options.interface';

const collectionPath = path.join(__dirname, '../collection.json');

function defaultOptions(): IOptions {
  return {
    manifest: 'src/custom-elements/test-manifest.json',
    importPath: '@tylertech/forge',
    exclude: '',
    outDir: '',
    outDirExcludePrefix: '',
    modulePrefix: '',
    useDefineFunction: false
  };
}

describe('custom-elements', () => {
  it('should generate a component and module for each element in a folder matching the tag name', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', defaultOptions(), Tree.empty());

    expect(tree.files).toEqual([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts',
      '/forge-expansion-panel/expansion-panel.component.ts',
      '/forge-expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should overwrite a module in the target directory if it includes the standard comment indicating it was generated', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const oldGeneratedFileContent = `// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.\nold content`
    const startingTree = Tree.empty();
    startingTree.create('forge-accordion/accordion.module.ts', oldGeneratedFileContent);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', defaultOptions(), startingTree);

    expect(tree.files).toEqual(jasmine.arrayContaining([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts'
    ]));
    expect(tree.get('forge-accordion/accordion.module.ts')?.content.toString()).not.toEqual(oldGeneratedFileContent);
  });

  it('should generating the module file ending in -proxy if one already exists in the target directory', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const startingTree = Tree.empty();
    const nonGeneratedContent = 'test';
    startingTree.create('forge-accordion/accordion.module.ts', nonGeneratedContent);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', defaultOptions(), startingTree);

    expect(tree.files).toEqual(jasmine.arrayContaining([
      '/forge-accordion/accordion.component.ts',
      '/forge-accordion/accordion.module.ts',
      '/forge-accordion/accordion-proxy.module.ts'
    ]));
    expect(tree.get('forge-accordion/accordion.module.ts')?.content.toString()).toEqual(nonGeneratedContent);
    expect(tree.get('forge-accordion/accordion-proxy.module.ts')?.content.toString()).toContain('export class AccordionProxyModule');
  });

  it('should generate the folders in the outDir if specified', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions(),
        outDir: 'test'
      }, Tree.empty());

    expect(tree.files).toEqual([
      '/test/forge-accordion/accordion.component.ts',
      '/test/forge-accordion/accordion.module.ts',
      '/test/forge-expansion-panel/expansion-panel.component.ts',
      '/test/forge-expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should omit the forge prefix from the folder if outDirExcludePrefix is specified', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions(),
        outDirExcludePrefix: 'forge-',
      }, Tree.empty());

    expect(tree.files).toEqual([
      '/accordion/accordion.component.ts',
      '/accordion/accordion.module.ts',
      '/expansion-panel/expansion-panel.component.ts',
      '/expansion-panel/expansion-panel.module.ts',
    ]);
  });

  it('should generate exclude a component by tag name', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions(),
        exclude: 'forge-accordion, forge-expansion-panel'
      }, Tree.empty());

    expect(tree.files).toEqual([]);
  });

  it('should use the built-in customElements.define function if useDefineFunction is false', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions(),
        useDefineFunction: false
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[0]);
    const moduleFile = tree.readContent(tree.files[1]);
    expect(componentFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
    expect(componentFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
    expect(moduleFile).toContain(`import { AccordionComponent as AccordionComponentCustomElement } from '@tylertech/forge';`);
    expect(moduleFile).toContain(`if (!window.customElements.get('forge-accordion')) {`);
    expect(moduleFile).toContain(`window.customElements.define('forge-accordion', AccordionComponentCustomElement);`);
  });

  it('should not generate inputs for readonly properties', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions()
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[2]);
    expect(componentFile).toContain(`public get testReadonlyProperty`);
    expect(componentFile).not.toContain(`public set testReadonlyProperty`);
  });

  it('should import and use booleanAttribute/numberAttribute transforms for @Input() properties ', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions()
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[2]);
    expect(componentFile).toMatch(/import { [\w\s,]*booleanAttribute[\w\s,]* } from '@angular\/core';/);
    expect(componentFile).toMatch(/import { [\w\s,]*numberAttribute[\w\s,]* } from '@angular\/core';/);
    expect(componentFile).toMatch(/@Input\({ transform: booleanAttribute }\)[\r\n\s]*public set open/m);
    expect(componentFile).toMatch(/@Input\({ transform: numberAttribute }\)[\r\n\s]*public set testNumber/m);
  });

  it('should not import booleanAttribute/numberAttribute if no usages ', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions()
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[0]);
    expect(componentFile).not.toMatch(/import { [\w\s,]*booleanAttribute[\w\s,]* } from '@angular\/core';/);
    expect(componentFile).not.toMatch(/import { [\w\s,]*numberAttribute[\w\s,]* } from '@angular\/core';/);
  });

  it('should generate components that expose the native element with tag name in description ', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions()
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[2]);
    expect(componentFile).toMatch(/\/\*\* The forge-expansion-panel element. \*\/[\r\n\s]*public readonly nativeElement = this.elementRef.nativeElement;/m);
  });

  it('should use the library define function if useDefineFunction is true', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', {
        ...defaultOptions(),
        useDefineFunction: true
      }, Tree.empty());

    const componentFile = tree.readContent(tree.files[0]);
    const moduleFile = tree.readContent(tree.files[1]);
    expect(componentFile).toContain(`, defineAccordionComponent } from '@tylertech/forge';`);
    expect(componentFile).toContain(`defineAccordionComponent()`);
    expect(moduleFile).toContain(`import { defineAccordionComponent } from '@tylertech/forge';`);
    expect(moduleFile).toContain(`defineAccordionComponent()`);
  });

  it('should accept a config file rather than individual arguments', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', { config: 'src/custom-elements/test-config.json' }, Tree.empty());

    expect(tree.files).toEqual([
      '/test/accordion/accordion.component.ts',
      '/test/accordion/accordion.module.ts',
      '/test/expansion-panel/expansion-panel.component.ts',
      '/test/expansion-panel/expansion-panel.module.ts'
    ]);
  });

  it('should accept a map of dependencies and generate imports/exports in the module', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner
      .runSchematic<IOptions>('custom-elements', { config: 'src/custom-elements/test-config.json' }, Tree.empty());

    const accordionModuleFile = tree.readContent(tree.files[1]);
    expect(accordionModuleFile).toContain(`import { ForgeExpansionPanelModule } from '../expansion-panel/expansion-panel.module';`);
    expect(accordionModuleFile).toContain(`imports: [CommonModule, ForgeExpansionPanelModule]`);
    expect(accordionModuleFile).toContain(`exports: [AccordionComponent, ForgeExpansionPanelModule]`);
  });

  it('should inject providers and allow access to nativeElement, zone, and changeDetectorRef', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner.runSchematic<IOptions>('custom-elements', defaultOptions(), Tree.empty());
    const componentFile = tree.readContent(tree.files[0]);

    expect(componentFile).toMatch(/protected elementRef = inject<ElementRef<AccordionComponentCustomElement>>\(ElementRef\)/);
    expect(componentFile).toMatch(/protected zone = inject\(NgZone\)/);
    expect(componentFile).toMatch(/const changeDetectorRef = inject\(ChangeDetectorRef\)/);
    expect(componentFile).toMatch(/public readonly nativeElement = this\.elementRef\.nativeElement/);
  });

  it('should generate components that are not standalone', async () => {
    const runner = new SchematicTestRunner('schematics', collectionPath);
    const tree = await runner.runSchematic<IOptions>('custom-elements', defaultOptions(), Tree.empty());
    const componentFile = tree.readContent(tree.files[0]);
    expect(componentFile).toMatch(/standalone:\s*false/);
  });

});